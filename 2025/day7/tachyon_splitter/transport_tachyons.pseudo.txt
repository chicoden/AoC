memory(
    u8[] input, padding?,
    u64[] tachyons_in,
    u64[] tachyons_out
)

grid_width = 0
start_pos = 0
loop
    if input[grid_width] == 'S'
        start_pos = grid_width

    elif input[grid_width] == ('\r' or '\n')
        break

    grid_width++
// found grid width
line_stride = grid_width + 1 // one past the terminating newline
if last char == '\r' // stupid fucking windows
    line_stride++ // we would like to skip past carriage returns yes please
    // assume all line endings are the same

tachyons_in = round_up(&input[sizeof(input)], alignof(u64))
tachyons_out = tachyons_in + grid_width * sizeof(u64)
total_size = tachyons_out + grid_width * sizeof(u64)

current_size = memory.size * 64KiB
if current_size < total_size
    memory.grow ceil((total_size - current_size) / 64KiB)

line_start = &input[line_stride]
tachyons_in_count = 1
tachyons_in[0] = start_pos
loop
    if line_start == &input[sizeof(input)]
        break // reached end of input

    tachyon_index = 0
    tachyon_out_count = 0
    loop
        if tachyon_index == tachyons_in_count
            break // processed all incoming tachyons
        tachyon_pos = tachyons_in[tachyon_index]

        if line_start[tachyon_pos] == '.'
            // propagate into free space
            line_start[tachyon_pos] = '|'
            tachyons_out[tachyon_out_count++] = tachyon_pos

        elif line_start[tachyon_pos] == '^'
            if tachyon_pos > 0
                if line_start[tachyon_pos - 1] == '.'
                    // split left
                    line_start[tachyon_pos - 1] = '|'
                    tachyons_out[tachyon_out_count++] = tachyon_pos - 1

            if tachyon_pos < grid_width-1
                if line_start[tachyon_pos + 1] == '.'
                    // split right
                    line_start[tachyon_pos + 1] = '|'
                    tachyons_out[tachyon_out_count++] = tachyon_pos + 1

        tachyon_index++

    swap(tachyons_in, tachyons_out)
    tachyons_in_count = tachyons_out_count
    line_start += line_stride