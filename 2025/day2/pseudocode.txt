halt = 0
loop:
    push 0 # add accumulator for first ID in range
    loop:
        ch = in()
        if ch > 47: # is digit
            push(pop() * 10 + (ch - '0')) # shift in digit
            #push '0', sub
            #roll depth=2 rolls=1 # roll accumulator to the top
            #push 10, mul, add
        elif ch > 44: # dash
            push 0 # add new accumulator for last ID in range
        elif ch > 43: # comma
            break
        else: # newline
            halt = 1
            #roll depth=3 rolls=2 # roll halt flag to the top
            #pop, push 1
            #roll depth=3 rolls=1 # roll it back to the bottom
            break
    # [halt, start, end] on stack

    total = 0
    range_lo = 1
    loop:
        # [halt, start, end, total, range_lo] on stack
        range_hi = 10 * range_lo - 1
        multiplier = 10 * range_lo + 1

        # [halt, start, end, total, range_lo, multiplier]
        # [halt, start, end, total, range_lo, multiplier, multiplier] <- dup
        # [halt, start, end, total, multiplier, multiplier, range_lo] <- roll depth=3 rolls=2
        # [halt, start, end, total, multiplier, multiplier, range_lo, range_lo] <- dup
        # [halt, start, end, total, range_lo, multiplier, multiplier, range_lo] <- roll depth=4 rolls=1
        # [halt, start, end, total, range_lo, multiplier, multiplier * range_lo] <- mul
        # [halt, start, total, range_lo, multiplier, multiplier * range_lo, end] <- roll depth=5 rolls=4
        # [halt, start, total, range_lo, multiplier, multiplier * range_lo, end, end] <- dup
        # [halt, start, end, total, range_lo, multiplier, multiplier * range_lo, end] <- roll depth=6 rolls=1
        if range_lo * multiplier > end: # no further ranges intersect the search range
            break

        # [halt, start, end, total, range_lo, multiplier] on stack
        lo_multiple = ceildiv(start, multiplier) # (start + multiplier-1) / multiplier
        hi_multiple = floordiv(end, multiplier)
        # must sum multiples in the intersection between the ranges [lo_multiple, hi_multiple] and [range_lo, range_hi]

        # clip range
        if range_lo > lo_multiple:
            lo_multiple = range_lo
        if hi_multiple > range_hi:
            hi_multiple = range_hi

        if lo_multiple > hi_multiple:
            # empty intersection
            continue

        # calculate sum of range of multiples and add it to the total
        total += (hi_multiple * (hi_multiple + 1) - (lo_multiple - 1) * lo_multiple) / 2 * multiplier
        range_lo *= 10

#[halt, start, end, total]
#[start, end, total, halt] <- roll depth=4 rolls=3
#[start, end, total, halt, halt] <- dup
#[halt, start, end, total, halt] <- roll depth=5 rolls=1
#[halt, start, end, total] <- point
    if halt > 0:
        break

out
pop
pop
pop

































































